---
title: '[Server Programming] WSARecv에서 IOCP를 쓸 때, lpNumberOfBytesRecved 사용 여부'
date: "2026-01-09"
---
### 기존 코드 중
`비동기 RECV IO를 요청하는 부분`
```CPP
	DWORD recvbytes = 0;
	...
	int retRecv = WSARecv(socket_, buf, 2, &recvbytes, &flags, (WSAOVERLAPPED*)&overlappedRecv_, NULL);
```

서버의 IOCP코드 부분이다. **lpNumberOfBytesRecvd** 인자에 스택의 주소를 넘겨주고 있다.

아래는 **MSDN의 WSARecv 함수(winsock2.h)** 파트 내용 중 일부분이다. 한번 읽어보자

```
[out] lpNumberOfBytesRecvd

수신 작업이 즉시 완료되는 경우 이 호출에서 받은 데이터의 수(바이트)에 대한 포인터입니다.

잠재적으로 잘못된 결과를 방지하려면 lpOverlapped 매개 변수가 NULL이 아닌 경우 이 매개 변수에 NULL을 사용합니다. lpOverlapped 매개 변수가 NULL이 아닌 경우에만 이 매개 변수는 NULL일 수 있습니다.
```

즉, 오버랩드 IO를 사용할때에는 인자로 NULL을 사용하는걸 권장한다는 말이다. 그렇다면 기존의 코드가 결함이라는것 일까? 

### 결함인가?
내 서버에서는 해당 코드로 인한 버그는 발견할 수 없었다. 자료를 서칭해봤을때

DEFAULT세팅에서의 IOCP에서 WSARecv를 호출했을때 즉시완료(0반환) or WSA_IO_PENDING 든 둘 다 completion port에 큐잉이 된다.

**WSA_IO_PENDING일때**, 어차피 lpNumberOfBytesRecvd를 건들지않는다. 그러니 반환되고 이 사라진 스택에 접근하는 일은 일어나지 않는다... 그리고 수신크기는 완료통지에서 따로 주어진다. (하지만, **결함까진 아니더라도**, MSDN에 따라 NULL로 설정하는것이 좋을 것으로 생각한다. 음... "**잠재적으로 잘못된 결과를 방지**" <-- 이게 뭘까??)

그럼 **즉시완료(0반환)일때는?** 위에서 얘기한대로 어차피 큐잉이 되어서 워커스레드가 깨어나기 때문에 쓸 일이 없다.

### IOCP이지만, 필요하다면?
SetFileCompletionNotificationModes함수에서 `FILE_SKIP_COMPLETION_PORT_ON_SUCCESS` 옵션을 사용한다면, 즉시완료되었을때, completion port에 큐잉하지않는다. **즉, 즉시완료가 된 시점에서 기존의 완료통지 후처리를 진행해주어야한다.**

그렇다면 이때는 **lpNumberOfBytesRecvd**가 필요하다. 근데 굳이?  
직접 처리한다면, 불필요한 컨택스트 스위칭을 줄이는 효과를 볼 수 있다.
하지만, 그만큼 후처리 코드가 완료통지 + 즉시완료시 두 영역에서 작성되어야 할 것이다.

### 코드 리팩토링
사용하지 않는다면 제거하는 것이 좋다고 생각한다. 다른 사람이 봤을 때 주석도 없이 사용되고 있으니, 혹시 즉시완료 후에 직접 처리를 해줘야하는 건가? 라고 의심할수도 있으니..

https://github.com/OneCrazyman/game-server-portfolio/commit/b294e681a120d304f5f2ae8da3d8afb2a3eb07ea

---
### 참고
https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-wsarecv

https://learn.microsoft.com/ko-kr/windows/win32/api/winbase/nf-winbase-setfilecompletionnotificationmodes

https://stackoverflow.com/questions/28756844/wsarecv-and-the-lpnumberofbytesrecvd-parameter