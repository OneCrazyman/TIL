---
title: '[baekjoon/c#] [Gold IV] 거짓말 - 1043 : 노가다 그리고 유니온파인드'
date: '2025-11-25'
---
# [Gold IV] 거짓말 - 1043 

[문제 링크](https://www.acmicpc.net/problem/1043) 

### 성능 요약

메모리: 6172 KB, 시간: 56 ms

### 분류

그래프 이론, 자료 구조, 그래프 탐색, 분리 집합

### 제출 일자

2025년 11월 25일 17:46:28

### 문제 설명

<p>지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.</p>

<p>사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.</p>

<p>둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.</p>

<p>셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.</p>

<p>N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.</p>

### 출력 

 <p>첫째 줄에 문제의 정답을 출력한다.</p>

### 첫번째 소스
```c#
// 1043번
// 진실을 알게되는 모든 집합을 먼저 구한다
// 그 다음 진실이 속한 파티일 경우 카운팅을 제외한다

// 집합 업데이트 시간복잡도
// while 반복 n번
//      m개 파티검사 m번
//          파티당 n명 검사
// => O(n^2*m) = 50^3 = 125'000 (ok)

using System;
using System.Collections.Generic;
using System.Linq;
namespace algorithm_study
{
    class main
    {
        static int N;
        static int M;
        static void Main(string[] args)
        {
            int[] nm = Console.ReadLine().Split().Select(int.Parse).ToArray();
            N = nm[0];
            M = nm[1];

            int[] truth = Console.ReadLine().Split().Select(int.Parse).ToArray();
            int truthCount = truth[0];

            HashSet<int> knowTruth = new HashSet<int>();
            for (int i = 1; i <= truthCount; i++)
            {
                knowTruth.Add(truth[i]);
            }

            List<HashSet<int>> partyList = new List<HashSet<int>>();
            for (int i = 0; i < M; i++)
            {
                int[] party = Console.ReadLine().Split().Select(int.Parse).ToArray();
                int peopleParty = party[0];
                HashSet<int> hs = new HashSet<int>();
                for (int j = 1; j <= peopleParty; j++)
                {
                    hs.Add(party[j]);
                }
                partyList.Add(hs);
            }

            bool updated = true;

         	// 집합 찾아서 업데이트
            while (updated)
            {
                updated = false;
                for (int i = 0; i < M; i++)
                {
                    bool hasCommon = knowTruth.Overlaps(partyList[i]);
                    if (hasCommon)
                    {
                        foreach (var p in partyList[i])
                        {
                            bool newTruth = knowTruth.Add(p);
                            if (newTruth)
                                updated = true;
                        }
                    }
                }
            }

            int ans = 0;
            for (int i = 0; i < M; i++)
            {
                bool hasCommon = knowTruth.Overlaps(partyList[i]);
                if (!hasCommon)
                {
                    ans++;
                }
            }
            Console.WriteLine(ans);
        }
    }
}
```

### 해결과정
문제의 요지는 **진실을 아는사람들의 집합**을 순차 업데이트할때, 이전의 해당이 안된다고 생각한 경우에 다시 영향을 준다는것이다.

즉, 접촉한 사람들도 진실을 아는사람들이 되기 때문에,,, 앞전의 순차 업데이트 과정에서 진실을 모르는 파티라고 가정했더라도 **사실 진실을 알수도 있다** 라는것이고

그러면 진실을 알았을때, 진실 집합을 업데이트 하게될 경우, 다시 처음부터 업데이트를 하면 되지 않을까? 라고 생각하여 3중 루프문을 구성했고 복잡도도 충분하다 생각해 그대로 구현을 하였다.

### 더 좋은 방법 - 정석적인 방법? - 유니온 파인드
다들 유니온파인드를 활용해서 풀었더라..

3중 루프문까지 구성하지않아, 성능적인 측면에서 유리하다.

### 유니온 파인드를 적용
```c#
// 1043번

// 유니온파인드
// 진실을 알고있는 노드의 부모노드 값을 0으로, 각 파티구성원들끼리 union한다.
// union 구현시 부모 노드 값이 작은것이 큰값을 대체하도록 한다. (그래야 최종적으로 부모노드가 0이 되기때문)
// 유니온 파인드 후, 파티리스트를 순회하며 아무 노드를 find한 결과가 0이 아니여야 거짓말 가능한 집단이므로 카운트한다.

// 파티 M번당, 최대 N개끼리 Union
// => O(M*N) = 50^2


using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;

namespace algorithm_study
{
    class main
    {
        static void Union(int s,int e) {
            s = Find(s);
            e = Find(e);

            if (s > e)
                parent[s] = e;
            else
                parent[e] = s;
        }

        static int Find(int n)
        {
            if (n != parent[n])
            {
                parent[n] = Find(parent[n]);
            }
            return parent[n];
        }

        const int MAX_LEN = 50;
        static int[] parent = new int[MAX_LEN + 1];
        static void Main(string[] args)
        {
            var sr = new StreamReader(Console.OpenStandardInput());
            var sw = new StreamWriter(Console.OpenStandardOutput());

            string[] nm = sr.ReadLine().Split();
            int N = int.Parse(nm[0]);
            int M = int.Parse(nm[1]);

            string[] t = sr.ReadLine().Split();
            int truthCount = int.Parse(t[0]);

            int[] knowTruth = new int[truthCount];
            for (int i = 0; i < truthCount; i++)
            {
                knowTruth[i] = int.Parse(t[i+1]);
            }
            int[][] partyArr = new int[M][];
            for (int i = 0; i < M; i++)
            {
                string[] partys = sr.ReadLine().Split();
                int partyCount = int.Parse(partys[0]);
                partyArr[i] = new int[partyCount];
                for (int j = 0; j < partyCount; j++)
                {
                    partyArr[i][j] = int.Parse(partys[j+1]);
                }
            }

            // 유니온파인드전 초기화
            for (int i=1; i<=N; i++)
            {
                parent[i] = i;
            }

            foreach (var know in knowTruth)
            {
                //Union(0,know);
                parent[know] = 0;
            }

            for (int i=0; i<M; i++)
            {
                int len = partyArr[i].Length;
                for (int j=0; j<len-1; j++)
                {
                    Union(partyArr[i][j], partyArr[i][j+1]);
                }
            }

            int ans = 0;
            for (int i=0; i<M; i++)
            {
                int result = Find(partyArr[i][0]);
                if (result != 0)
                {
                    ans++;
                }
            }

            sw.WriteLine(ans);
            sw.Flush();
        }
    }
}

```