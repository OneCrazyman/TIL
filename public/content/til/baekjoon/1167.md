---
title: '[baekjoon/c#] [Gold II] 트리의 지름 - 1167 : 트리의 지름 (미해결)'
date: 2025-12-01
---

# [Gold II] 트리의 지름 - 1167 

[문제 링크](https://www.acmicpc.net/problem/1167) 

### 성능 요약

메모리: 43788 KB, 시간: 260 ms

### 분류

그래프 이론, 그래프 탐색, 트리, 깊이 우선 탐색, 트리의 지름

### 제출 일자

2025년 12월 1일 17:45:12

### 문제 설명

<p>트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.</p>

<p>먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.</p>

### 출력 

 <p>첫째 줄에 트리의 지름을 출력한다.</p>

### 통과된 제출코드
```cs
// 인접리스트로 입력받고
// dfs, 완전탐색

using System;
using System.Collections.Generic;

namespace algorithm_study
{
    class main
    {
        struct Node {
            public int edge;
            public int value;
        }

        static List<Node>[] nodes = new List<Node>[100_001];
        static bool[] visited = new bool[100_001]; 
        public static void Main(String[] args)
        {
            for (int i = 0; i < 100_001; i++)
            {
                nodes[i] = new List<Node>();
            }

            int V = int.Parse(Console.ReadLine());
            for (int i = 0; i < V; i++) { 
                string[] num = Console.ReadLine().Trim().Split(' ');
                int v1 = int.Parse(num[0]);
                for (int j=1; j<num.Length-1; j+=2)
                {
                    int v2 = int.Parse(num[j]);
                    int e = int.Parse(num[j+1]);
                    nodes[v1].Add(new Node { edge=v2,value=e });
                    //Console.Write($"{v2}:{e}, ");
                }
            }
            int answer = 0;
            int tmp = 0;
            dfs(1,ref tmp);
            ClearVisited();
            answer = dfs(tmp,ref tmp);

            Console.WriteLine(answer);
            return;
        }

        public static int dfs(int vertex, ref int deepVertex)
        {
            visited[vertex] = true;
            int sum = 0;
            int maxsum = 0;
            deepVertex = vertex;
            foreach (Node node in nodes[vertex])
            {
                if (visited[node.edge]) continue;
                int tmpVertex = 0;
                sum = dfs(node.edge,ref tmpVertex) + node.value;
                maxsum = Math.Max(sum, maxsum);
                if (maxsum == sum) {
                    deepVertex = tmpVertex;
                }
            }
            return maxsum;
        }

        public static void ClearVisited() {
            Array.Clear(visited, 0, visited.Length);
        }
    }
}
```

### 과정
트리의 지름을 구하는 문제로 
처음에 dfs로 모든 노드에서 완전탐색을 하면 결과는 나오겠다라고 생각하면서도, 문제 조건에 의해 O(n^2)로 시간초과가 뜨겠다라고 생각했다.

하지만, 끝내 다른 방법이 떠오르지 않아 일단 완전 탐색으로 구현을 완료한 뒤에, 풀이를 찾아보았다.

### DFS 2번으로 지름 구하기
트리의 최대 지름을 두번의 DFS로 구할 수 있었다.
공식은 1. 임의의 노드로 부터 가장 먼 노드를 찾는다.
2. 위에서 가장 먼 노드로부터 가장 먼 노드를 찾았을때의 거리가 트리의 지름이다.

해당 공식으로 기존의 DFS에서,, 리프노드에 도착했을때 레퍼런스로 정점 값을 넘기고, 가장 긴 경로로 업데이트 할때마다 레퍼런스로 다시 정점값을 넘겨주도록 구현하였다.
최종적으로 가장 먼 노드끼리의 길이를 반환하면서 레퍼런스에 해당 정점 값을 레퍼런스로 받을 수 있게하였다.

원리는 다음시간에 알아보자..