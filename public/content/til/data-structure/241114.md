---
title: "[Data Structure] 32bit/ 64bit 자료형 크기"
date: 2024-11-14
---
### 자료형의 크기들 (윈도우)
| 자료형 | 32bit | 64bit |
|--------|-------|-------|
| int    | 4(byte)| 4     |
| char	 | 1	|	1 |	
| short  | 2     | 2     |
| long   | 4     | 4     | (리눅스는 8byte : 64bit)
| long long | 8  | 8     |
| float | 4  | 4     |
| double | 8  | 8     |
|size_t,ssize_t| 4		| 8	|
|pointer| 4		| 8		|
|int*| 4		| 8		|
|long*| 4		| 8		|
|char*| 4		| 8		|

### 자료형에 관한 이야기
자료형의 크기를 보다보면 궁금한게 생긴다.
32비트에서 long과 int의 크기는 같네? 등등

이는 16비트 시절 int의 크기가 2byte이기 때문에
16 비트 운영체제에서는 2byte보다 큰 long 4byte를 쓰기 위해 만들어졌을 것이고,
long long은 32비트 시절 long보다 큰 정수형을 담기 위해서 만들어졌을 것이다.

그리고 자료형의 크기는 공식적으로 정해져있지 않다. 다만 각 자료형의 상대적인 대소는 지키도록 컴파일러를 설계하고 있다. 
`short <= int <= long <= longlong`

어떤 비트의 운영체제에 따라 특성이 다르기 때문에 캐스트를 할때는 항상 주의하여 적용해야할 것 이다.

이를테면 32 bit에서는 int형과 ptr형의 자료형이 같지만 64비트에선 그렇지 않고, 64bit에서 long을 int로 cast할때 값손실이 발생 가능.

포인터 자료형에 관해, 포인터는 주소를 담는 변수이다. 그러니 32비트는 4바이트의 주소를, 64비트는 8바이트의 주소로 값을 가진다. 어떠한 자료형의 포인터형이라도 모두 각자 운영체제에 맞는 같은 크기를 배정받는다.