---
title: "[c++] 클래스, 객체, 접근제어"
date: 2024-05-14
---
### 메세지
메세지를 통해 다른 소프트웨어 객체와 통신하며 상호작용한다.

- 메세지 전달
	- 객체에 메세지를 보낼때, 해당하는 멤버 함수를 호출

- 메세지의 매개변수 = 호출되는 함수의 매개변수

### 클래스
- 같은 클래스로 생성된 객체는 각기 다른 상태값을 가지는것이 가능.
	- 객체마다 값을 저장할 공간이 필요

- 멤버 함수
	- 같은 클래스인 객체의 함수는 동일하다. 함수를 공유.

### string 클래스
문자열을 나타내는 클래스
문자열 저장과 처리에 필요한 변수와 함수가 정의

```cpp
string s1 = "hello world!"
```
![alt text](image-8.png)

- +, = 연산자를 통해 결합과 할당이 가능
- ==, < 연산자를 통한 문자열 비교 가능
- cin에서 공백문자가 있으면 입력이 중단

getline() 함수
- 전체 라인 읽기
	```cpp 
	string input;
	getline(cin,input);
	```

### 객체의 동적 생성
- 객체에 대한 포인터를 사용
```cpp
Car *dynCar = new Car; // 동적 객체 생성
dynCar->speed = 100; // 동적 객체 사용
dynCar->speedUp(); // 동적 객체 사용
...
delete dynCar; // 동적 객체 삭제
```

### 정적 객체와 동적 객체의 차이점
- 정적 객체(static object)
	- 메모리의 스택(stack) 영역에 할당
	- 해당 객체가 선언된 스코프내에서 수명이 정해짐.

- 동적 객체(dynamic object)
	- 힙(heap) 영역에 할당
	- 수명을 직접 제어, 코더의 양날의 검
	- 반드시 delete를 통해 명시적으로 메모리를 해제하여야 메모리 누수를 방지한다.

*힙(heap)에 대하여
- 이진트리(binary tree)의 형태, 완전 이진트리의 형태를 일반적으로 가짐.
- 우선순위 큐를 구현하는데 사용, 최댓값같은 값을 빠르게 찾을 수 있는 자료구조
- 완전 이진트리에서 모든 각 노드에 힙 속성(heap property)의 조건이 부합해야한다.

- 힙은 일반적으로 배열을 기반으로 구현. 배열의 인덱스 0은 사용되지 않으며, 루트 노드는 배열의 인덱스 1에 위치한다. 힙은 다음과 같은 특성을 가짐.
	- 인덱스 i에 위치한 노드의 왼쪽 자식은 인덱스 2\*i에 위치합니다.  
	인덱스 i에 위치한 노드의 오른쪽 자식은 인덱스 2\*i + 1에 위치합니다.  
	인덱스 i에 위치한 노드의 부모는 인덱스 i/2에 위치합니다.

#최소힙으로 구성된 이진트리 예시
```
           3
         /   \
        5     9
       / \   / \
      8  12 11 14
```

## 접근제어(access control)
- 외부에서 특정한 멤버 변수나 멤버 함수에 접근하는것을 제어하는것
- private, public
- 멤버 변수를 전용 멤버로 설정하여 은닉화, 캡슐화의 목적을 지키는 것이 권유

- 접근자와 설정자를 통해서 멤버 변수에 접근하자

- 접근자(accerror) 자바의 getter
- 설정자(mutator) 자바의 setter

- 접근자는 반환하는 데이터의 형식을 제어할 수 있다.
➔ 외부 코드가 실제 데이터 표현 방식을 모르게 할 수 있다.  

### 멤버 함수 외부 정의
- 클래스 내부에 정의
	- 자동적으로 인라인(inline) 함수가 된다
	- 멤버 함수 호출이 멤버 함수의 코드로
대치된다

- 클래스 외부에 정의
	- 일반적인 함수와 동일하게 호출한다
	- 스택에 인수들을 저장하고 복귀 주소
를 저장한 후에 멤버 함수로 제어가 이
동한다

정리
- 멤버 함수의 크기가 작은 경우 : 클래스 내부에 정의
- 큰 경우 : 클래스 외부에 정의 (인라인의 경우 코드 복사가 여러번 일어나 파일의 크기가 커짐)

__함수, 변수의 선언(declaration)과 정의(definition)__  

### 클래스의 선언과 클래스의 정의 분리
- 클래스 헤더파일과 소스 파일을 분리하여 작성
	- 헤더 파일에 클래스 선언 (car.h)
	- 소스 파일에 클래스 정의 (car.cpp)

	- 클래스 사용시, 헤더파일을 포함하여 사용
	- 객체를 생성해서 사용

__멤버함수 중복 정의(overloading)__
```cpp
void print(int x) {
    std::cout << "Integer: " << x << std::endl;
}

void print(double x) {
    std::cout << "Double: " << x << std::endl;
}
```

## 구조체
- c언어의 구조체 : 클래스에서 멤버 함수를 제외하면 구조체가 됨
- c++에서의 구조체 : 클래스와 같은 의미
	```cpp
	struct BankAccount { // 은행계좌
		int accountNumber; // 계좌번호
		int balance; // 잔액을표시하는변수
		double interest_rate; // 연이자
		double get_interrest(int days){
			return (balance*interest_rate)*((double)days/365.0);
		}
	};

	```